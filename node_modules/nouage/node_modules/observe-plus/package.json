{
  "name": "observe-plus",
  "description": "Extra features for ES7's Object.observe",
  "version": "3.0.3-beta",
  "homepage": "http://podefr.github.com/observe-plus/",
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/podefr/observe-plus/master/LICENSE"
    }
  ],
  "files": [
    "src",
    "LICENSE"
  ],
  "dependencies": {
    "asap": "~1.0.0",
    "nested-property": "0.0.6"
  },
  "author": {
    "name": "Olivier Scherrer",
    "email": "pode.fr@gmail.com"
  },
  "devDependencies": {
    "chai": "~1.10.0",
    "sinon": "~1.8.1"
  },
  "keywords": [
    "ES7",
    "Object.observe",
    "Array.observe",
    "observe"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:podefr/observe-plus.git"
  },
  "bugs": {
    "url": "https://github.com/podefr/observe-plus/issues"
  },
  "main": "src/observe-plus.js",
  "engines": {
    "node": ">= 0.11.10"
  },
  "scripts": {
    "test": "mocha --harmony specs/*",
    "watch": "mocha --watch --harmony specs/*",
    "jshint": "jshint src/* specs/*"
  },
  "readme": "# Observe+ (Now observes on nested objects/arrays!)\n\nObserve+ is a library based on [Object.observe/Array.observe](http://wiki.ecmascript.org/doku.php?id=harmony:observe) that adds the following features:\n\n- [x] fine-grained observe on individual properties/index/event types\n- [x] observe nested objects and arrays\n- [x] pause/resume to do batch updates on the data structure before publishing all the events\n- [x] observe once to remove the event listener after an event has fired\n- [x] disposable pattern for removing listeners\n\n## What is Object.observe?\n\nhttp://addyosmani.com/blog/the-future-of-data-binding-is-object-observe/\n\nReference: http://arv.github.io/ecmascript-object-observe/\n\n### Compatible browsers:\n\nCheck Kangax' ES compat' table to see where Object.observe (ES7) is available : http://kangax.github.io/es5-compat-table/es6/#Object.observe_%28part_of_b_ES7_/b_%29\n\n## Installation:\n\n```bash\nnpm install observe-plus\n```\n\n## How to use?\n\nRemember that you need to have Object.observe and Array.observe in order for observe-plus to work:\n\n### In node.js\n\nRun with the --harmony option:\n\n```bash\nnode --harmony myscript.js\n```\n\n### In Chrome\n\nenable the harmony flag, navigate to [chrome://flags/#enable-javascript-harmony](chrome://flags/#enable-javascript-harmony)\n\n## API\n\n```js\nvar observePlus = require(\"observe-plus\");\n```\n\n### Observing objects:\n\nObject.observe() listens to changes happening on an object. Usually, we are interested in two types of events:\n\n- When a property is added, updated, or removed from an object:\n\n```js\nvar object = {};\n// I want to know when a new property is added\nobject.newProperty = \"value\";\n\n// and when a property is updated\nobject.newProperty = \"newValue\";\n\n// or when it's removed\ndelete object.newProperty;\n```\n\n- When the value of a specific property changes:\n\n```js\nvar object = { property: \"value\"};\n\n// I want to observe object.property to know when the value changes:\nobject.property = \"newValue\";\nobject.property = \"otherValue\";\n\n```\n\nObserve+ allows to listen to these two types.\n\n#### Observing generic events on the object such as property added, updated, removed:\n\n```js\nvar plainObject = {};\n\nvar observer = observePlus.observe(plainObject);\n\n// Listening to properties being added to the object\nvar dispose = observer.observe(\"add\", function (publishedEvent) {\n\t// When a property is be added to the object,\n\t// this callback will be called with this === scope\n\t// and publishedEvent as the original event such as, for example:\n\tpublishedEvent.name == \"newProperty\";\n\tpublishedEvent.object === plainObject;\n\tpublishedEvent.type == \"add\";\n\tpublishedEvent.value == \"value\";\n}, scope /* optional */);\n\n// This will trigger the listeners that have subscribed to \"add\"\nplainObject.newProperty = \"value\";\n\n// This will add a listener to properties being updated\nobserver.observe(\"update\", function (publishedEvent) { ... }, scope /* optional */);\n\n// This listener will be called only once and then disposed of\nobserver.observeOnce(\"update\", function (publishedEvent) { ... }, scope /* optional */);\n\n// This will trigger the listeners that have subscribed to \"update\"\nplainObject.newProperty = \"newValue\";\n\n// This listener will be called when a property is deleted from the object\nobserver.observe(\"delete\", function (publishedEvent) { ... }, scope /* optional */);\n\n// This listener will be called only once and then disposed of\nobserver.observeOnce(\"delete\", function (publishedEvent) { ... }, scope /* optional */);\n\n// This will trigger the listeners that have subscribed to \"delete\"\ndelete plainObject.newProperty;\n\n// When you're done with a listener, you can remove it by calling the dispose function that is the observe() method returned.\n// All the observe methods return a dispose function.\ndispose();\n```\n\n#### Observing changes on specific properties of the object:\n\n```js\n// Listening to changes on the \"newProperty\" property\nvar dispose = observer.observeValue(\"newProperty\", function (publishedEvent) {\n\t// When newProperty will be added/modified or removed,\n\t// this callback will be called with this === scope\n\t// and publishedEvent as the original event such as, for example:\n\tpublishedEvent.name === \"newProperty\";\n\tpublishedEvent.object === plainObject;\n\tpublishedEvent.type === \"add\";\n\tpublishedEvent.value === \"value\";\n}, scope /* optional */);\n\n// Or similar, but the listener will be called only once:\nobserver.observeOnce(\"newProperty\", function (publishedEvent) { ...}, scope /* optional */);\n\n// This will call the callback with the \"add\" event\nplainObject.newProperty = \"value\";\n\n// This will call the callback with the \"update\" event\nplainObject.newProperty = \"newValue\";\n\n// This will call the callback with the \"delete\" event\ndelete plainObject.newProperty;\n\n// This will not call the callback as it's not listening to events on anotherProperty\nplainObject.anotherProperty = \"value\";\n\n// When you're done with a listener, you can remove it by calling the dispose function that is the observe() method returned.\n// All the observe methods return a dispose function.\ndispose();\n```\n\nStop observing changes on this object:\n\n```js\nobserver.unobserve();\n```\n\n### Observing arrays:\n\nAs for arrays, we may be interested in:\n\n- Listening to changes on the array such as item added/removed (splice) or updated (update):\n\n```js\nvar array = [];\n// I want to know when an item is added:\narray.push(\"newItem\");\n\n// When an item is updated\narray[0] = \"updatedItem\";\n\n// When an item is removed\narray.splice(0, 1);\n```\n\n- Listening to changes on a specific index of the array:\n\n```js\nvar array = [\"item\"];\n\n// I want to know when array[0] is updated:\narray[0] = \"newValue\";\narray[0] = \"otherValue\";\n```\n\n#### Observing generic events on the array such as item added, updated, removed:\n\n```js\nvar plainArray = [];\n\nvar observer = observePlus.observe(plainArray);\n\n// Listening to changes on the array such as item added or removed\nvar dispose = observer.observe(\"splice\", function (publishedEvent) { ... }, scope /* optional */);\n\n// Listening to splice events only once:\nobserver.observeOnce(\"splice\", function (publishedEvent) { ... }, scope /* optional */);\n\n// This will trigger all the listeners that have subscribed to \"splice\"\nplainArray.push(\"item\");\n\n// Listening to updates on the items\nobserver.observe(\"update\", function (publishedEvent) { ... }, scope /* optional */);\n\n// This will trigger all the listeners that have subscribed to \"update\"\nplainArray[0] = \"newValue\";\n\n// This will again trigger all the listeners that have subscribed to \"splice\"\nplainArray.pop();\n\n// When you're done with a listener, you can remove it by calling the dispose function that is the observe() method returned.\n// All the observe methods return a dispose function.\ndispose();\n```\n\n#### Observing events on specific items from the array:\n\n```js\nvar dispose = observer.observeValue(10, function (publishedEvent) { ... }, scope /* optional */);\n\n// Or to listen index 10 only once:\nobserver.observerIndexOnce(10, function (publishedEvent) { ... }, scope /* optional */);\n\n// This will trigger all the listeners that have subscribed to changes on item 10:\nplainArray[10] = \"item\";\n\n// Removing the listener\ndispose();\n```\n\nTrick: if you use Object.observe on the array, you can also listen to \"length\" changes as it's a property of the object\n\n```js\nvar observer = observePlus.observe(plainArray);\n\nobserver.observeValue(\"length\", function (publishedEvent) { ... }, scope /* optional */);\n```\n\nStop observing changes:\n\n```js\nobserver.unobserve();\n```\n\n### Observing nested properties!\n\nObserve+ can also watch for generic events or events on specific items/properties from nested objects and arrays!\n\nGiven this data structure:\n\n```js\nvar dataStructure = [\n    {\n        id: 0,\n        name: \"Alice\",\n        colors: [\"red\", \"green\"]\n    },\n\n    {\n        id: 1,\n        name: \"Bob\",\n        colors: [\"yellow\", \"pink\"]\n    },\n    \n    {\n        id: 2,\n        name: \"Carol\",\n        colors: [\"purple\"]\n    }\n];\n```\n\nI can watch this dataStructure:\n\n```js\nvar observer = object.observe(dataStructure);\n```\n\nthen I can watch if Alice's preferred color changes:\n\n```js\nobserver.observeValue(\"0.colors.0\", function (event) {\n    // do something when 0.colors.0 changes.\n    // event.value will hold the new color\n    // event.oldValue will hold the old color\n});\n\n\n// Will trigger the event\ndataStructure[0].colors[0] = \"blue\";\n```\n\n### Pause/resume:\n\nThe events are fired asynchronously, on the next turn of the event loop. This should allow for rendering to be delayed until all computation is done. If you still want to delay the trigger further, you can pause the observer and resume it later, by using the pause/resume API:\n\n```js\n// Pause the observer\nobserver.pause();\n\n// do something on object/array;\n\n// resume the observer, which will trigger all the listeners with the events:\nobserver.resume();\n```\n\nNote that resume() will also trigger the callbacks asynchronously, to be consistent with Object.observe and Array.observe.\n\n## Changelog\n\n## 3.0.3 - Beta - 08 MAR 2015\n\n* All events have an oldValue property\n\n### 3.0.2 - Beta - 05 MAR 2015\n\n* Fix bug where oldValue was incorrectly resolved to undefined\n\n### 3.0.1 - Beta - 05 MAR 2015\n\n* Fix various bugs when modifying parent of observed nested objects that would prevent\nsome events being properly published\n\n### 3.0.0 - Beta - 25 FEB 2015\n\n* Fix a bug preventing splice events from triggering\n* Fix performance issue when triggering events for many event listeners\n* Update documentation\n\n### 3.0.0 - Alpha - 17 FEB 2015\n\n* Can observe nested objects and arrays\n* Add current value of the watched property to the event object\n* Unified observeArray and observeObject using polymorphism\n* Using destroy terminology instead of unobserve\n* Add isPaused method\n\n### 2.1.0 - 28 DEC 2014\n\n* Added .observe that either uses observeArray or observeObject depending on the type of the model to watch\n* [Breaking Change] observeIndex(Once) and observeProperty(Once) are renamed to observeValue(Once).\n* [Breaking Change] Removed bower support and standalone versions of observe-plus for the browser.\n\n### 2.0 - 28 DEC 2014\n\nBeta versions\n\n### 1.0.1 - 5 MAR 2014\n\n* Now throws an error when trying to observe an object in a runtime that doesn't have Object.observe\n\n### 1.0.0\n\nfirst release\n\n## License:\n\nMIT",
  "readmeFilename": "README.md",
  "_id": "observe-plus@3.0.3-beta",
  "_from": "observe-plus@>=3.0.3-beta <3.1.0"
}
